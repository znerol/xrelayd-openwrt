diff -ur xrelayd-0.1/Makefile xrelayd-0.1-x509write/Makefile
--- xrelayd-0.1/Makefile	2007-09-01 14:31:20.000000000 +0200
+++ xrelayd-0.1-x509write/Makefile	2007-09-01 12:00:28.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id: Makefile 8 2007-09-01 12:31:20Z lo $
+# $Id: Makefile 2 2007-09-01 10:00:28Z lo $
 # 
 # if you want to compile against a compiled but not installed xyssl sourcetree
 # XYSSL_SOURCE=/path/to/xyssl-src
diff -ur xrelayd-0.1/xrelayd.c xrelayd-0.1-x509write/xrelayd.c
--- xrelayd-0.1/xrelayd.c	2007-09-01 14:31:20.000000000 +0200
+++ xrelayd-0.1-x509write/xrelayd.c	2007-09-18 20:52:53.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: xrelayd.c 8 2007-09-01 12:31:20Z lo $
+/* $Id: xrelayd.c 10M 2007-09-17 08:11:30Z (local) $
  *
  * Copyright (c) 2007, Lorenz Schori <lo@znerol.ch>
  * All rights reserved.
@@ -68,6 +68,10 @@
 // FIXME. configurable?
 #define RUNNING_DIR "/"
 
+#define DEFAULT_CERT_SUBJECT "CN='localhost'"
+#define DEFAULT_CERT_TIMESPAN 31536000
+#define DEFAULT_KEY_SIZE 1024
+
 void dolog(int prio, const char *fmt, ...);
 
 #ifdef NDEBUG
@@ -87,15 +91,22 @@
  */
 int xrly_ciphers[] =
 {
-    // TLS1_EDH_RSA_AES_256_SHA,
-    // SSL3_EDH_RSA_DES_168_SHA,
+#if !defined(NO_AES)
     TLS1_RSA_AES_256_SHA,
+#endif
+#if !defined(NO_DES)
     SSL3_RSA_DES_168_SHA,
-    // SSL3_RSA_RC4_128_SHA,
-    // SSL3_RSA_RC4_128_MD5,
+#endif
+#if !defined(NO_ARC4)
+    SSL3_RSA_RC4_128_SHA,
+    SSL3_RSA_RC4_128_MD5,
+#endif
     0
 };
 
+/* key generation */
+#define EXPONENT 65537
+
 int             servermode = 1;
 char            *dst_host = "localhost";
 int             dst_port    = 0;
@@ -133,7 +144,14 @@
                     "    -r      connect to remote machine on [host:]port\n"
                     "    -P      pidfile\n"
                     "    -f      foreground mode\n"
-                    "    -D      syslog level (0...7)\n");
+                    "    -D      syslog level (0...7)\n"
+		    "\n"
+		    "  Options for private key and x509 certificate generation\n"
+ 		    "    -K      generate private key optional arg=keylen, default: %d\n"
+		    "    -U      generate certificate with optional arg=subject line,\n"
+		    "            default: \"%s\"\n"
+		    "    -Y      number of days before this cert becomes invalid\n"
+		    "\n",DEFAULT_KEY_SIZE,DEFAULT_CERT_SUBJECT);
     exit(status);
 }
 
@@ -250,12 +268,12 @@
      *  Connect to other party
      */
     int     server_fd;
-    ILOG("Attempting to connect to %s:%d", srv_host, srv_port);
+    DLOG("Attempting to connect to %s:%d", srv_host, srv_port);
     if( ( ret = net_connect( &server_fd, srv_host, srv_port ) ) != 0 ) {
         ELOG("Failed to connect to %s:%d: %08x, %s", srv_host, srv_port, ret, strerror(errno));
         return;
     }
-    ILOG("Connected to %s:%d", srv_host, srv_port);
+    DLOG("Connected to %s:%d", srv_host, srv_port);
     
     /*
      *  Setup ssl
@@ -294,7 +312,7 @@
         ssl_set_sidtable( &ssl, session_table );
     }
     
-    ILOG("Initialized SSL for %s mode",sslserver ? "server" : "client");
+    DLOG("Initialized SSL for %s mode",sslserver ? "server" : "client");
     
     /*
      *  disable nagle algorithm
@@ -309,16 +327,16 @@
      *  Handshake & Co
      */
     if(sslserver) {
-        ILOG("Performing ssl handshake");
+        DLOG("Performing ssl handshake");
         ret = ssl_server_start( &ssl );
         if(ret) {
             ELOG("Failed to start ssl server: %08x", ret);
             return;
         }
-        ILOG("Handshake succeded");
+        DLOG("Handshake succeded");
     }
     
-    NLOG("Connected %s client %d.%d.%d.%d to %s server %s:%d",
+    ILOG("Connected %s client %d.%d.%d.%d to %s server %s:%d",
         sslserver ? "ssl" : "plain", client_ip[0],client_ip[1],client_ip[2],client_ip[3],
         sslserver ? "plain" : "ssl", srv_host, srv_port);
     
@@ -427,12 +445,9 @@
     memset( &ssl, 0, sizeof( ssl ) );
     
     net_close(client_fd);
-    ILOG("Closed %s connection from %d.%d.%d.%d",client_fd==*ssl_fd ? "ssl" : "plain",
-        client_ip[0],client_ip[1],client_ip[2],client_ip[3]);
     net_close(server_fd);
-    ILOG("Closed %s connection to %s:%d",server_fd==*ssl_fd ? "ssl" : "plain",srv_host,srv_port);
     
-    NLOG("Closed connection between %s client %d.%d.%d.%d and %s server %s:%d",
+    ILOG("Closed connection between %s client %d.%d.%d.%d and %s server %s:%d",
         sslserver ? "ssl" : "plain", client_ip[0],client_ip[1],client_ip[2],client_ip[3],
         sslserver ? "plain" : "ssl", srv_host, srv_port);
 }
@@ -446,14 +461,17 @@
     char            *certfile = NULL; //"certSrv.pem";
     // int             vlevel = 0;
     char            *cpos;
-    int             intarg,tmpport;
-    char            c;
-    
+    int             c,intarg,tmpport,genkey=0,gencert=0,exitaftergen=0,keysize=DEFAULT_KEY_SIZE;
+    char	    *cert_subject=DEFAULT_CERT_SUBJECT;
+    time_t	    cert_notbefore=time(NULL);
+    time_t	    cert_notafter=0;
+    int		    cert_timespan=DEFAULT_CERT_TIMESPAN;
+
     // return code
     int             status=1;
     
     for (;;) {
-        c = getopt (argc, argv, "VD:P:fo:cd:r:p:A:v:h");
+        c = getopt (argc, argv, "VD:P:fo:cd:r:p:A:K::U::Y:v:h");
         if (c == -1) {
             break;
         }
@@ -553,7 +571,33 @@
             case 'V':
                 // version
                 break;
-                
+
+	    case 'K':
+		// generate keys
+		genkey=1;
+		if(optarg) {
+		    keysize=strtol(optarg,NULL,0);
+		    if(keysize>2048 || keysize<128) {
+			usage(1);
+		    }
+		}
+		break;
+	    
+	    case 'U':
+		// generate certificate
+		gencert=1;
+		if(optarg) {
+		    cert_subject=optarg;
+		}
+		break;
+
+	    case 'Y':
+		cert_timespan = 86400 * strtol(optarg,NULL,0);
+		if(cert_timespan<=0) {
+		    usage(1);
+		}
+		break;
+            
             case '?':
             case 'h':
                 usage(0);
@@ -565,6 +609,15 @@
         }
     }
     
+    if(!srv_port || !dst_port) {
+	if(genkey || gencert) {
+	    exitaftergen=1;
+	}
+	else {
+	    usage(1);
+	}
+    }
+
 /* install handlers */
     signal(SIGCHLD,sigchld_handler); /* ignore child */
     signal(SIGQUIT,kill_handler); /* catch hangup signal */
@@ -578,36 +631,90 @@
     
     x509_cert       cert;
     rsa_context     key;
+    havege_state    hs;
     int             ret;
     
-    memset( &cert, 0, sizeof( x509_cert ) );
-    
-    if(certfile) {
-        ILOG("Loading the server certificate");
-        ret = x509_read_crtfile( &cert, certfile);
+    // key
+    if(genkey && servermode) {
+	// generate key if desired
+	ILOG("Generating private key with size: %d",keysize);
+	havege_init( &hs );
+	ret = rsa_gen_key( &key, keysize, EXPONENT, havege_rand, &hs);
+	if(ret) {
+	    ELOG("Failed to generate private key: %08x",ret);
+	    goto fail;
+	}
+	if(keyfile) {
+	    // write out PEM-keyfile here
+	    x509_write_keyfile(&key, keyfile, X509_OUTPUT_PEM); 
+	}
+    }
+    else if(keyfile) {
+        ILOG("Loading the private key");
+        ret = x509_read_keyfile(&key, keyfile, NULL);
         if(ret) {
-            ELOG("Failed to load server certificate: %08x, %s",ret,strerror(errno));
+            ELOG("Failed to load private key: %08x, %s",ret,strerror(errno));
             goto fail;
         }
     }
     else if(servermode){
-        ELOG("A certificate is required in server mode");
+        ELOG("A private key is required in server mode");
         usage(1);
     }
     
-    if(keyfile) {
-        ILOG("Loading the private key");
-        ret = x509_read_keyfile( &key, keyfile, NULL);
+    // cert
+    memset(&cert, 0, sizeof(x509_cert));
+    x509_raw raw_cert;
+    char    notbefore[24],notafter[24];
+
+    if(gencert && servermode) {
+	// generate self signed certificate
+	ILOG("Generating x509 certificate");
+	x509_init_raw(&raw_cert);
+
+	x509_add_pubkey(&raw_cert,&key);
+	x509_create_subject(&raw_cert,cert_subject);
+	
+	struct tm *tm;
+	tm=gmtime(&cert_notbefore);
+	strftime(notbefore,sizeof(notbefore),"%Y-%m-%d %H:%M:%S %Z",tm);
+
+	if(!cert_notafter) {
+	    cert_notafter=cert_notbefore + cert_timespan;
+	}
+	tm=gmtime(&cert_notafter);
+	strftime(notafter,sizeof(notafter),"%Y-%m-%d %H:%M:%S %Z",tm);
+	
+	x509_create_validity(&raw_cert,notbefore,notafter); 
+	x509_create_selfsign(&raw_cert,&key);
+	
+	// convert raw to cert.
+	x509_add_certs(&cert, raw_cert.raw.data, raw_cert.raw.len);
+
+	if(certfile) {
+	    // write cert in PEM format
+	    x509_write_crtfile(&raw_cert, certfile, X509_OUTPUT_PEM);	
+	}
+
+	x509_free_raw(&raw_cert);
+    }
+    else if(certfile) {
+        ILOG("Loading the server certificate");
+        ret = x509_read_crtfile(&cert, certfile);
         if(ret) {
-            ELOG("Failed to load private key: %08x, %s",ret,strerror(errno));
+            ELOG("Failed to load server certificate: %08x, %s",ret,strerror(errno));
             goto fail;
         }
     }
     else if(servermode){
-        ELOG("A private key is required in server mode");
+        ELOG("A certificate is required in server mode");
         usage(1);
     }
     
+    if(exitaftergen) {
+	goto succeed;
+    }
+
     // go to background
     if(!nofork) {
         daemonize();
@@ -663,13 +770,16 @@
         // parent
         close(client_fd);
     }
-    
+
+succeed: 
     status=0;
     
 fail:
-    NLOG("Closing server port %d",srv_port);
-    net_close(srv_fd);
-    
+    if(srv_port) {
+        NLOG("Closing server port %d",srv_port);
+	net_close(srv_fd);
+    }
+
     x509_free_cert( &cert );
     rsa_free( &key );
     
